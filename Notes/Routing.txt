More Routing
You can think of routing as the traffic control of your applications. When a request comes in, the routing for your application will determine where the request will go and how to generate the response. Let's create a new project called form_test that we will use in the next few sections. Go ahead and create the server.py file and a directory called templates:

server.py should look like this:

/form_test/server.py
from flask import Flask, render_template, request, redirect
app = Flask(__name__)
# our index route will handle rendering our form
@app.route('/')
def index():
  return render_template("index.html")
# this route will handle our form submission
# notice how we defined which HTTP methods are allowed by this route
@app.route('/users', methods=['POST'])
def create_user():
   print "Got Post Info"
   # we'll talk about the following two lines after we learn a little more
   # about forms
   name = request.form['name']
   email = request.form['email']
   # redirects back to the '/' route
   return redirect('/')
app.run(debug=True) # run our server
Copy
Let's go ahead and first make our index.html template:

/form_test/templates/index.html
<html>
    <head>
       <title>Form Test Index</title>
    </head>
    <body>
      <h1>Index Page</h1>
      <h3>Create a User</h3>
      <!-- read on to learn about form actions, we'll talk about the method in a later section -->
      <form action='/users' method='post'>
          Name: <input type='text' name='name'>
          Email: <input type='text' name='email'>
          <input type='submit' value='create user'>
      </form>
    </body>
</html>
Copy
Once you've done the above, start up your server and visit localhost:5000/ you should see your index page served up.

About Forms
The modern internet is user-driven; much of the actual content of a website is generated by the users of a website. How does the user manage to get his or her data to the page?? One word: forms. The HTML forms are the way in which users are able to pass data to the back end of a website where it can be processed and stored. Processing form data correctly is a huge part of what it takes to become a back-end developer.

Setting it Up
Let's build a basic form in HTML on index.html:

<form action='/users' method='post'>
    Name:<input type='text' name='name'>
    Email:<input type='text' name='email'>
    <input type='submit' value='Submit'>
</form>
The form we build above is a standard form that users can input their first and last names along with their email address. Let's take some time to discuss each individual HTML element and its attributes:

The form tag
Everything contained within the HTML form tags can be transmitted to another page: something I'm sure you've been curious about since you started working with HTML. How does this happen? Well, let's take a look at the attributes of the form tag.

The action attribute
The form's action attribute will be set equal to the route where the information, contained within the form, will be sent to. In this case, we are going to send the information to '/users'. All of our code for handling this form data will be contained in the '/users' route.

Note: /usersis just a route name. You can send your form to whatever route name you like. Just remember that every request/route has a URL and an HTTP verb or method.

The method attribute
There are two values that you will see this attribute being set to: GET and POST. If you remember HTTP requests, then you will remember that GET and POST are the two types of HTTP request methods that are most common. In addition to serving pages, a GET request is for insensitive information and a POST request is for passing sensitive information.

The method attribute specifies the type of HTTP request by how you, as the developer, want to have your form information transferred. If your form data contains password data, credit card numbers, SSNs, etc, please use POST! If the information is like a library search or something insensitive, it's OK to use GET as your method.

In general, you should associate forms with the POST method (in most cases), and sending responses with the GET method.

The input element
The form tag will set up all of the logistics, but the information you want to gather will be harvested from the elements you place within the form. In our basic example, we have just one type of input, a text field. There are several different input types that can gather data:

text - a basic collector for text
radio button - when you want the user to select from a number of options
password - like text but the text entered will be disguised (as circles!)
checkbox - when a user must be prompted for a yes or no type argument
see the rest here!
Decide on the input elements you want to include in your form. Each must be assigned a name attribute if you want each input to be recognized by your server-side code. When the HTML form gathers up your data it will create a set of key/value pairs with the name attributes as the keys and the data the user enters as the values. Notice in our form above that we give a name to each input element that reflects the information we want to gather.

And that's the front end! The form data will be sent to the server when the user clicks the submit button. The form data is organized into key/value pairs and submitted to the URL specified by your form's 'action' attribute using the HTTP method specified in your form's 'method' attribute.

Handling the POST request on the Server
Now recall our second route in our server.py file. This route corresponds to the action and method of our form:

# the server is listening for a POST request to:
# localhost:5000/users
# we define the route below such that the route matches the action of our form - '/users'
# similarly we need to allow specific methods - 'POST' in this case
@app.route('/users', methods=['POST'])
def create_user():
    print "Got Post Info"
    # recall the name attributes we added to our form inputs
    # to access the data that the user input into the fields we use request.form['name_of_input']
    name = request.form['name']
    email = request.form['email']
    return redirect('/') # redirects back to the '/' route
Specifying Allowed Methods
Our route is waiting to receive a POST request to the route because we specified the valid method types with:

methods=['POST']
It is possible to put more than one value into the methods array.

Accessing Data
We can access form data with this syntax:

request.form['name_of_input']
The name we gave to each HTML input was significant. On the server-side, we can access data that was input into a field from a user through the request.form dictionary by providing the name of the input as the key.

To see what's in your request object, try print request.form. What do you see? Hint: this might come in handy later for debugging.

We could then store that data:

my_data = request.form['name_of_input']
Lastly, note that the type of anything that comes in through request.form will be "String" no matter what. If you want that value to be identified as an actual number you'll have to type cast it.

Redirecting
Redirecting is critical, read the following carefully and implement it in the coming assignments.

Lastly, in our POST route we used the redirect method to send a new request to the '/' route. We can redirect to any route that we have defined:

return redirect('/route_goes_here')
Important! Always redirect after handling POST data to avoid data being handled more than once! Try it for yourself. Create a template with a form, then have that form submit to the '/users' route from the code snippet above. Create another HTML document, success.html. Change the create_user method as follows:

@app.route('/users', methods=['POST'])
def create_user():
   name = request.form['name']
   email = request.form['email']
	 # Here's the line that changed. We're rendering a template from a post route now.
   return render_template('success.html')
Now try reloading the page after you've submitted your form. This happens because you are re-submitting a request to your '/users' route every time you hit reload. It's not a big deal yet, but later you'll be re-adding values to a database every time you hit reload. Not only would that create a bad user experience, but it would also be an unnecessary strain on your server!

Last Notes
For now we are simply sending our POST information to a server but are not putting it to use. In the next section we will learn how to store that information in the database, retrieve it, and output it to other pages.
Privacy Policy
 catherine Hello,  Catherine B  
CHECKLIST
Advanced Routing
So far, we know we can pass data from the client to the server via forms. In this section we are going to learn: another way to pass data from the client to the server!

Passing data from the client to the server through the URL
We have already learned how to define basic route handlers that take care of any static route. What if we wanted to have a route '/users/___' where anything that comes after '/users/' was passed as a variable to the route handler. If we could do this then we could have '/users/jay' display a page that says "Hello Jay" and '/users/anna' display a page that says "Hello Anna" without writing two different route handlers!

Start with your server.py which should look like this:

/advanced_routing/server.py
from flask import Flask, render_template, request, redirect
app = Flask(__name__)
@app.route('/users/<username>')
def show_user_profile(username):
    print username
    return render_template("user.html")
app.run(debug=True)
Copy
As you can see, the route itself has a placeholder after the '/users/'. The placeholder is designated in <> tags where the name inside of the tags should match the parameter name that is passed to the route handler function.

If you run the code you'll see that any username you entered is then printed to your command line.

Let's go over the basic structure for getting variables from the URL:

@app.route('/route/with/<vararg>')
def handler_function(vararg):
  # here you can use the variable "vararg"
  # if you want to see what our argument looks like
  print vararg
  # we could do other things with this information from this point on such as:
  # use it to retrieve some records from the database
  # render a particular template
Copy
You can pass as many variables as you like in the URL as long as they are all passed as parameters to the route handler function:
@app.route('/users/<username>/<id>')
def show_user_profile(username, id):
	print username
	print id
    return render_template("user.html")
Copy
Try entering a url that will adhere to the above. What do you see in your command line?
Templates are HTML files that are interpreted by Flask and then served to the client. This is called rendering templates and every web development framework provides a way to render templates. Now, let's see how you can pass data to the template and display it dynamically!

Create a template to look like the following. Remember that all templates must be placed in a folder called templates.

<html>
  <head>
    <title>Template Test</title>
  <head>
  <body>
    <p>My name is {{name}}</p>
  </body>
</html>
Copy
Now, in our hello_world function definition change the return statement to be:

return render_template("index.html", name="Jay")
Copy
When you run the app you will see that {{name}} in the HTML file was replaced by the variable that we passed to the render_template function! Flask uses a templating engine called Jinja2 to parse through files looking for {{}}, replace variables with real values, and send a complete HTML file back to the client.

We'll go into more detail about inserting Python-like code into our templates in the next section.
Static content is any content that can be served up to the client without being modified, generated, or processed by the server. Every framework will have its own way of serving static content. Flask serves static content from a directory called static.. Much like our templates directory, the static directory must be called static. This static folder will be used to serve all of your stylesheets, images, and JavaScript files.

Now, say we placed a CSS file, a JavaScript file, and an image directly into our static folder. We can then access them in our HTML templates, like so:

<!-- linking a css style sheet -->
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='my_style_sheet.css') }}">
<!-- linking a javascript file -->
<script type="text/javascript" src="{{ url_for('static', filename='my_script.js') }}"></script>
<!-- linking an image -->
<img src="{{ url_for('static', filename='my_img.png') }}">
Note: although Flask knows to look for static files in the static directory, we must tell it when and where to do so, as shown above.

Organization
It is common to create a few more folders to organize our static files into categories according to document type. We can call them css, js, and img and house the corresponding files in the different folders. We can reflect these changes in our previous tags with the following changes in the href/src attributes. Notice the way we change the file name in the url_for function:

<!-- linking a css style sheet -->
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/my_style_sheet.css') }}">
<!-- linking a javascript file -->
<script type="text/javascript" src="{{ url_for('static', filename='js/my_script.js') }}"></script>
<!-- linking an image -->
<img src="{{ url_for('static', filename='img/my_img.png') }}">
A couple of things to remember:
All static content must go inside of the static folder
The folder must be named static
In order to reference the static content start at the relative path after static(static is from the root(also known as / or the same level as your server.py file
For example, if you have styles.css file in a directory called css in your static folder your href would read "href='css/styles.css'"

